# GRU ê¸°ë°˜ ë§¤ì¶œ ì˜ˆì¸¡ ëª¨ë¸ ì½”ë“œ ìƒì„¸ ì„¤ëª…

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#ê°œìš”)
2. [ì „ì²´ êµ¬ì¡°](#ì „ì²´-êµ¬ì¡°)
3. [ì£¼ìš” êµ¬ì„± ìš”ì†Œ ìƒì„¸ ì„¤ëª…](#ì£¼ìš”-êµ¬ì„±-ìš”ì†Œ-ìƒì„¸-ì„¤ëª…)
4. [ë°ì´í„° ì „ì²˜ë¦¬](#ë°ì´í„°-ì „ì²˜ë¦¬)
5. [ëª¨ë¸ êµ¬ì¡°](#ëª¨ë¸-êµ¬ì¡°)
6. [ì•™ìƒë¸” í•™ìŠµ](#ì•™ìƒë¸”-í•™ìŠµ)
7. [ì˜ˆì¸¡ ë° í›„ì²˜ë¦¬](#ì˜ˆì¸¡-ë°-í›„ì²˜ë¦¬)
8. [ì„±ëŠ¥ í‰ê°€](#ì„±ëŠ¥-í‰ê°€)

---

## ê°œìš”

ì´ ì½”ë“œëŠ” **GRU(Gated Recurrent Unit)** ì‹ ê²½ë§ì„ ì‚¬ìš©í•˜ì—¬ ì¼ì¼ ë§¤ì¶œì„ ì˜ˆì¸¡í•˜ëŠ” ì‹œê³„ì—´ ì˜ˆì¸¡ ëª¨ë¸ì…ë‹ˆë‹¤. íŠ¹íˆ **Seed Ensemble** ê¸°ë²•ì„ í†µí•´ ì—¬ëŸ¬ ëª¨ë¸ì˜ ì˜ˆì¸¡ì„ í‰ê· ë‚´ì–´ ë” ì•ˆì •ì ì´ê³  ì •í™•í•œ ì˜ˆì¸¡ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

### ì£¼ìš” íŠ¹ì§•
- **ì‹œê³„ì—´ ë°ì´í„° ì²˜ë¦¬**: Sliding Window ë°©ì‹ìœ¼ë¡œ ì‹œí€€ìŠ¤ ë°ì´í„° ìƒì„±
- **ì•™ìƒë¸” í•™ìŠµ**: 5ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ì‹œë“œë¡œ í•™ìŠµí•œ ëª¨ë¸ì˜ ì˜ˆì¸¡ê°’ í‰ê· 
- **ë‹¤ì–‘í•œ íŠ¹ì§• ê³µí•™**: ë‚ ì§œ íŠ¹ì§•, ì§€ì—°(lag) íŠ¹ì§•, ë¡¤ë§ í†µê³„ ë“±
- **í›„ì²˜ë¦¬ ë¡œì§**: íœ´ì¼/íœ´ë¬´ì¼ ê°•ì œ 0ì› ì²˜ë¦¬, ë…¸ì´ì¦ˆ ì œê±°

---

## ì „ì²´ êµ¬ì¡°

```
1. í™˜ê²½ ì„¤ì • ë° ì‹œë“œ ê³ ì •
2. í‰ê°€ ì§€í‘œ í•¨ìˆ˜ ì •ì˜
3. ë°ì´í„° ì „ì²˜ë¦¬ í•¨ìˆ˜ë“¤
4. ì‹œí€€ìŠ¤ ìƒì„± (Sliding Window)
5. Dataset & Model í´ë˜ìŠ¤ ì •ì˜
6. ì˜ˆì¸¡ í•¨ìˆ˜
7. ë©”ì¸ ì‹¤í–‰ (ì•™ìƒë¸” í•™ìŠµ ë° í‰ê°€)
```

---

## ì£¼ìš” êµ¬ì„± ìš”ì†Œ ìƒì„¸ ì„¤ëª…

### 1. ì‹œë“œ ê³ ì • í•¨ìˆ˜ (`set_seed`)

```python
def set_seed(seed=42):
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    if torch.cuda.is_available():
        torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False
```

**ëª©ì **: ì¬í˜„ ê°€ëŠ¥í•œ ì‹¤í—˜ì„ ìœ„í•´ ëª¨ë“  ëœë¤ ì‹œë“œë¥¼ ê³ ì •í•©ë‹ˆë‹¤.

**ì‘ë™ ì›ë¦¬**:
- `random.seed()`: Python ë‚´ì¥ ëœë¤ ëª¨ë“ˆ ì‹œë“œ ê³ ì •
- `np.random.seed()`: NumPy ëœë¤ ì‹œë“œ ê³ ì •
- `torch.manual_seed()`: PyTorch CPU ì—°ì‚° ì‹œë“œ ê³ ì •
- `torch.cuda.manual_seed_all()`: GPU ì—°ì‚° ì‹œë“œ ê³ ì •
- `cudnn.deterministic = True`: CuDNNì˜ ë¹„ê²°ì •ì  ì•Œê³ ë¦¬ì¦˜ ë¹„í™œì„±í™”
- `cudnn.benchmark = False`: CuDNN ìë™ íŠœë‹ ë¹„í™œì„±í™”

**ì•™ìƒë¸”ì—ì„œì˜ í™œìš©**: ê° ëª¨ë¸ë§ˆë‹¤ ë‹¤ë¥¸ ì‹œë“œ(42, 100, 2024, 777, 999)ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì˜ ë‹¤ì–‘ì„±ì„ í™•ë³´í•©ë‹ˆë‹¤.

---

### 2. í‰ê°€ ì§€í‘œ í•¨ìˆ˜ (`calculate_metrics`)

```python
def calculate_metrics(y_true, y_pred):
    mae = np.mean(np.abs(y_true - y_pred))
    rmse = np.sqrt(np.mean((y_true - y_pred)**2))
    smape = np.mean(np.abs(y_true[mask] - y_pred[mask]) / denom[mask]) * 100
    return mae, rmse, smape
```

**ê³„ì‚°í•˜ëŠ” ì§€í‘œ**:

1. **MAE (Mean Absolute Error)**: í‰ê·  ì ˆëŒ€ ì˜¤ì°¨
   - ê³µì‹: `mean(|ì‹¤ì œê°’ - ì˜ˆì¸¡ê°’|)`
   - í•´ì„: ì˜ˆì¸¡ ì˜¤ì°¨ì˜ í‰ê·  í¬ê¸° (ë‹¨ìœ„: ì›)

2. **RMSE (Root Mean Squared Error)**: í‰ê·  ì œê³±ê·¼ ì˜¤ì°¨
   - ê³µì‹: `sqrt(mean((ì‹¤ì œê°’ - ì˜ˆì¸¡ê°’)Â²))`
   - í•´ì„: í° ì˜¤ì°¨ì— ë” í° íŒ¨ë„í‹°ë¥¼ ë¶€ì—¬ (ë‹¨ìœ„: ì›)

3. **SMAPE (Symmetric Mean Absolute Percentage Error)**: ëŒ€ì¹­ í‰ê·  ì ˆëŒ€ ë°±ë¶„ìœ¨ ì˜¤ì°¨
   - ê³µì‹: `mean(|ì‹¤ì œê°’ - ì˜ˆì¸¡ê°’| / ((|ì‹¤ì œê°’| + |ì˜ˆì¸¡ê°’|) / 2)) * 100`
   - í•´ì„: ë°±ë¶„ìœ¨ë¡œ í‘œí˜„ëœ ìƒëŒ€ì  ì˜¤ì°¨ (ë‹¨ìœ„: %)

---

## ë°ì´í„° ì „ì²˜ë¦¬

### 3.1 ë§¤ì¶œ ë°ì´í„° ì •ì œ (`clean_sales`)

```python
def clean_sales(df):
    if df['ì¼ë§¤ì¶œ'].dtype == 'object':
        df['ì¼ë§¤ì¶œ'] = df['ì¼ë§¤ì¶œ'].astype(str).str.replace(",", "").str.replace(" ", "").str.strip()
    df['ì¼ë§¤ì¶œ'] = pd.to_numeric(df['ì¼ë§¤ì¶œ'], errors='coerce').fillna(0)
    return df
```

**ëª©ì **: ë¬¸ìì—´ë¡œ ì €ì¥ëœ ë§¤ì¶œ ë°ì´í„°ë¥¼ ìˆ«ìë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

**ì²˜ë¦¬ ê³¼ì •**:
1. ë¬¸ìì—´ì¸ ê²½ìš° ì‰¼í‘œ(`,`)ì™€ ê³µë°± ì œê±°
2. `pd.to_numeric()`ìœ¼ë¡œ ìˆ«ì ë³€í™˜ (ì‹¤íŒ¨ ì‹œ `NaN`)
3. `NaN` ê°’ì„ 0ìœ¼ë¡œ ì±„ì›€

---

### 3.2 ë‚ ì§œ íŠ¹ì§• ì¶”ê°€ (`add_date_features`)

```python
def add_date_features(df):
    df['month'] = df['ì˜ì—…ì¼ì'].dt.month
    df['day'] = df['ì˜ì—…ì¼ì'].dt.day
    df['weekday'] = df['ì˜ì—…ì¼ì'].dt.weekday
    df['is_weekend'] = (df['weekday'] >= 5).astype(int)
    
    # ì£¼ê¸°ì  ì¸ì½”ë”© (Cyclic Encoding)
    df['month_sin'] = np.sin(2 * np.pi * df['month']/12)
    df['month_cos'] = np.cos(2 * np.pi * df['month']/12)
    df['day_sin'] = np.sin(2 * np.pi * df['day']/31)
    df['day_cos'] = np.cos(2 * np.pi * df['day']/31)
    
    # ì˜ì—… ì‹œê°„ ì„¤ì •
    df['open_hours'] = 11
    df.loc[df['weekday'] == 5, 'open_hours'] = 6  # í† ìš”ì¼
    df.loc[df['weekday'] == 6, 'open_hours'] = 0  # ì¼ìš”ì¼
    return df
```

**ì¶”ê°€ë˜ëŠ” íŠ¹ì§•**:

1. **ê¸°ë³¸ ë‚ ì§œ íŠ¹ì§•**:
   - `month`: ì›” (1~12)
   - `day`: ì¼ (1~31)
   - `weekday`: ìš”ì¼ (0=ì›”ìš”ì¼, 6=ì¼ìš”ì¼)
   - `is_weekend`: ì£¼ë§ ì—¬ë¶€ (0 ë˜ëŠ” 1)

2. **ì£¼ê¸°ì  ì¸ì½”ë”© (Cyclic Encoding)**:
   - **ì™œ í•„ìš”í•œê°€?**: ì›”(12ì›”)ê³¼ ì›”(1ì›”)ì€ ìˆ«ììƒìœ¼ë¡œëŠ” ë©€ì§€ë§Œ ì‹¤ì œë¡œëŠ” ê°€ê¹Œìš´ ì‹œì ì…ë‹ˆë‹¤. ì´ë¥¼ ëª¨ë¸ì´ ì´í•´í•  ìˆ˜ ìˆë„ë¡ sin/cos ë³€í™˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
   - `month_sin`, `month_cos`: ì›”ì˜ ì£¼ê¸°ì„± í‘œí˜„
   - `day_sin`, `day_cos`: ì¼ì˜ ì£¼ê¸°ì„± í‘œí˜„
   - ì˜ˆ: 12ì›”ê³¼ 1ì›”ì˜ sin/cos ê°’ì´ ë¹„ìŠ·í•˜ê²Œ ë§¤í•‘ë¨

3. **ì˜ì—… ì‹œê°„**:
   - í‰ì¼: 11ì‹œê°„
   - í† ìš”ì¼: 6ì‹œê°„
   - ì¼ìš”ì¼: 0ì‹œê°„ (íœ´ë¬´)

---

### 3.3 ì§€ì—° ë° ë¡¤ë§ íŠ¹ì§• ì¶”ê°€ (`add_lag_features`)

```python
def add_lag_features(df):
    df['lag1'] = df['ì¼ë§¤ì¶œ'].shift(1)      # 1ì¼ ì „ ë§¤ì¶œ
    df['lag7'] = df['ì¼ë§¤ì¶œ'].shift(7)      # 7ì¼ ì „ ë§¤ì¶œ (1ì£¼ì¼)
    df['lag14'] = df['ì¼ë§¤ì¶œ'].shift(14)    # 14ì¼ ì „ ë§¤ì¶œ (2ì£¼ì¼)
    df['lag28'] = df['ì¼ë§¤ì¶œ'].shift(28)    # 28ì¼ ì „ ë§¤ì¶œ (4ì£¼ì¼)
    
    df['roll_mean7'] = df['ì¼ë§¤ì¶œ'].rolling(7).mean()   # 7ì¼ ì´ë™í‰ê· 
    df['roll_mean14'] = df['ì¼ë§¤ì¶œ'].rolling(14).mean() # 14ì¼ ì´ë™í‰ê· 
    df['roll_mean28'] = df['ì¼ë§¤ì¶œ'].rolling(28).mean() # 28ì¼ ì´ë™í‰ê· 
    
    df['roll_std7'] = df['ì¼ë§¤ì¶œ'].rolling(7).std()     # 7ì¼ ì´ë™í‘œì¤€í¸ì°¨
    df['roll_std28'] = df['ì¼ë§¤ì¶œ'].rolling(28).std()   # 28ì¼ ì´ë™í‘œì¤€í¸ì°¨
    return df
```

**ëª©ì **: ì‹œê³„ì—´ ë°ì´í„°ì˜ ì‹œê°„ì  íŒ¨í„´ì„ ëª¨ë¸ì— ì œê³µí•©ë‹ˆë‹¤.

**íŠ¹ì§• ì„¤ëª…**:

1. **Lag íŠ¹ì§• (ì§€ì—° íŠ¹ì§•)**:
   - `lag1`: ì–´ì œ ë§¤ì¶œ â†’ ìµœê·¼ íŠ¸ë Œë“œ ë°˜ì˜
   - `lag7`: 1ì£¼ì¼ ì „ ë§¤ì¶œ â†’ ì£¼ê°„ íŒ¨í„´ ë°˜ì˜
   - `lag14`: 2ì£¼ì¼ ì „ ë§¤ì¶œ â†’ 2ì£¼ ì£¼ê¸° íŒ¨í„´
   - `lag28`: 4ì£¼ì¼ ì „ ë§¤ì¶œ â†’ ì›”ê°„ íŒ¨í„´ ë°˜ì˜

2. **ë¡¤ë§ í‰ê·  (Rolling Mean)**:
   - ìµœê·¼ Nì¼ì˜ í‰ê·  ë§¤ì¶œ â†’ ë‹¨ê¸°/ì¤‘ê¸° íŠ¸ë Œë“œ í‘œí˜„
   - ë…¸ì´ì¦ˆë¥¼ ì¤„ì´ê³  ì¶”ì„¸ë¥¼ ê°•ì¡°

3. **ë¡¤ë§ í‘œì¤€í¸ì°¨ (Rolling Std)**:
   - ìµœê·¼ Nì¼ì˜ ë³€ë™ì„± í‘œí˜„
   - ë§¤ì¶œì˜ ë¶ˆì•ˆì •ì„±ì„ ì¸¡ì •

**ì£¼ì˜ì‚¬í•­**: `shift()`ì™€ `rolling()` ì—°ì‚°ìœ¼ë¡œ ì¸í•´ ì´ˆê¸° í–‰ë“¤ì€ `NaN`ì´ ë©ë‹ˆë‹¤. ì´í›„ `.dropna()`ë¡œ ì œê±°í•©ë‹ˆë‹¤.

---

### 4. ì‹œí€€ìŠ¤ ìƒì„± (`create_sequences`)

```python
def create_sequences(df, feature_cols, target_col, seq_len=28):
    X, y = [], []
    feature_vals = df[feature_cols].values
    target_vals = df[target_col].values
    
    for i in range(seq_len, len(df)):
        seq_x = feature_vals[i-seq_len+1 : i+1]
        if len(seq_x) == seq_len:
            X.append(seq_x)
            y.append(target_vals[i])
    return np.array(X), np.array(y)
```

**ëª©ì **: ì‹œê³„ì—´ ë°ì´í„°ë¥¼ RNN/LSTM/GRUê°€ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ì‹œí€€ìŠ¤ í˜•íƒœë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

**ì‘ë™ ì›ë¦¬**:
- **Sliding Window ë°©ì‹**: ê¸¸ì´ 28ì˜ ìœˆë„ìš°ë¥¼ í•œ ì¹¸ì”© ì´ë™í•˜ë©° ì‹œí€€ìŠ¤ ìƒì„±
- ì˜ˆì‹œ (`seq_len=28`):
  - ì‹œí€€ìŠ¤ 1: [ë‚ ì§œ 0~27ì˜ íŠ¹ì§•] â†’ ë‚ ì§œ 27ì˜ ë§¤ì¶œ ì˜ˆì¸¡
  - ì‹œí€€ìŠ¤ 2: [ë‚ ì§œ 1~28ì˜ íŠ¹ì§•] â†’ ë‚ ì§œ 28ì˜ ë§¤ì¶œ ì˜ˆì¸¡
  - ì‹œí€€ìŠ¤ 3: [ë‚ ì§œ 2~29ì˜ íŠ¹ì§•] â†’ ë‚ ì§œ 29ì˜ ë§¤ì¶œ ì˜ˆì¸¡
  - ...

**ì…ë ¥ í˜•íƒœ**:
- `X`: `(ìƒ˜í”Œ ìˆ˜, ì‹œí€€ìŠ¤ ê¸¸ì´, íŠ¹ì§• ìˆ˜)` í˜•íƒœì˜ 3ì°¨ì› ë°°ì—´
- `y`: `(ìƒ˜í”Œ ìˆ˜,)` í˜•íƒœì˜ 1ì°¨ì› ë°°ì—´

---

## ëª¨ë¸ êµ¬ì¡°

### 5.1 Dataset í´ë˜ìŠ¤ (`SequenceDataset`)

```python
class SequenceDataset(Dataset):
    def __init__(self, X, y):
        self.X = torch.tensor(X, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.float32).unsqueeze(1)
    
    def __len__(self): 
        return len(self.X)
    
    def __getitem__(self, idx): 
        return self.X[idx], self.y[idx]
```

**ëª©ì **: PyTorchì˜ `DataLoader`ì™€ í˜¸í™˜ë˜ë„ë¡ ë°ì´í„°ì…‹ì„ ë˜í•‘í•©ë‹ˆë‹¤.

**ì£¼ìš” ë©”ì„œë“œ**:
- `__len__()`: ë°ì´í„°ì…‹ í¬ê¸° ë°˜í™˜
- `__getitem__()`: ì¸ë±ìŠ¤ì— í•´ë‹¹í•˜ëŠ” ìƒ˜í”Œ ë°˜í™˜
- `unsqueeze(1)`: `(N,)` â†’ `(N, 1)` í˜•íƒœë¡œ ë³€í™˜ (ë°°ì¹˜ ì²˜ë¦¬ í˜¸í™˜)

---

### 5.2 GRU ëª¨ë¸ (`GRUModel`)

```python
class GRUModel(nn.Module):
    def __init__(self, input_dim, hidden_dim=128, num_layers=2, dropout=0.3):
        super().__init__()
        self.gru = nn.GRU(input_dim, hidden_dim, num_layers=num_layers, 
                          batch_first=True, dropout=dropout)
        self.fc = nn.Linear(hidden_dim, 1)
        self.relu = nn.ReLU()
    
    def forward(self, x):
        out, _ = self.gru(x)
        return self.fc(self.relu(out[:, -1, :]))
```

**ëª¨ë¸ êµ¬ì¡°**:

```
ì…ë ¥ (batch_size, seq_len, input_dim)
    â†“
GRU ë ˆì´ì–´ (2ì¸µ, hidden_dim=128)
    â†“
ë§ˆì§€ë§‰ ì‹œí€€ìŠ¤ ì¶œë ¥ ì„ íƒ (out[:, -1, :])
    â†“
ReLU í™œì„±í™” í•¨ìˆ˜
    â†“
ì™„ì „ì—°ê²°ì¸µ (Linear: hidden_dim â†’ 1)
    â†“
ì¶œë ¥ (batch_size, 1) - ì˜ˆì¸¡ ë§¤ì¶œê°’
```

**í•˜ì´í¼íŒŒë¼ë¯¸í„° ì„¤ëª…**:

1. **`input_dim`**: ì…ë ¥ íŠ¹ì§•ì˜ ê°œìˆ˜ (19ê°œ)
2. **`hidden_dim=128`**: GRUì˜ ì€ë‹‰ ìƒíƒœ ì°¨ì›
3. **`num_layers=2`**: GRU ë ˆì´ì–´ë¥¼ 2ì¸µ ìŒ“ìŒ (ë” ë³µì¡í•œ íŒ¨í„´ í•™ìŠµ)
4. **`dropout=0.3`**: ê³¼ì í•© ë°©ì§€ë¥¼ ìœ„í•œ ë“œë¡­ì•„ì›ƒ ë¹„ìœ¨
5. **`batch_first=True`**: ë°°ì¹˜ ì°¨ì›ì´ ì²« ë²ˆì§¸ ì°¨ì› (PyTorch ê¸°ë³¸ê°’ì€ False)

**GRUì˜ ì¥ì **:
- LSTMë³´ë‹¤ íŒŒë¼ë¯¸í„°ê°€ ì ì–´ í•™ìŠµì´ ë¹ ë¦„
- ì¥ê¸° ì˜ì¡´ì„± í•™ìŠµì— íš¨ê³¼ì 
- ì‹œê³„ì—´ ì˜ˆì¸¡ì— ë„ë¦¬ ì‚¬ìš©ë¨

---

## ì•™ìƒë¸” í•™ìŠµ

### 6.1 Seed Ensemble ì „ëµ

```python
SEEDS = [42, 100, 2024, 777, 999]
all_preds = []

for i, seed in enumerate(SEEDS):
    set_seed(seed)  # ì‹œë“œ ë³€ê²½
    
    # ëª¨ë¸ ì´ˆê¸°í™” ë° í•™ìŠµ
    model = GRUModel(...)
    # ... í•™ìŠµ ê³¼ì • ...
    
    # ì˜ˆì¸¡
    preds = flexible_forecast_raw(...)
    all_preds.append(preds)

# í‰ê·  ê³„ì‚°
avg_preds = np.mean(all_preds, axis=0)
```

**ì•™ìƒë¸”ì˜ ëª©ì **:
- **ì•ˆì •ì„± í–¥ìƒ**: ë‹¨ì¼ ëª¨ë¸ì˜ ì˜ˆì¸¡ ë³€ë™ì„±ì„ ì¤„ì„
- **ì •í™•ë„ í–¥ìƒ**: ì—¬ëŸ¬ ëª¨ë¸ì˜ ì˜ˆì¸¡ì„ í‰ê· ë‚´ì–´ ë” ë‚˜ì€ ì„±ëŠ¥
- **ì¼ë°˜í™” ëŠ¥ë ¥**: ë‹¤ì–‘í•œ ì´ˆê¸°í™”ë¡œ ëª¨ë¸ì˜ ë‹¤ì–‘ì„± í™•ë³´

**ì‘ë™ ì›ë¦¬**:
1. 5ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ì‹œë“œë¡œ ëª¨ë¸ì„ ì´ˆê¸°í™”
2. ê° ëª¨ë¸ì„ ë…ë¦½ì ìœ¼ë¡œ í•™ìŠµ
3. ê° ëª¨ë¸ì˜ ì˜ˆì¸¡ê°’ì„ ìˆ˜ì§‘
4. ì˜ˆì¸¡ê°’ë“¤ì˜ í‰ê· ì„ ìµœì¢… ì˜ˆì¸¡ìœ¼ë¡œ ì‚¬ìš©

**ì™œ íš¨ê³¼ì ì¸ê°€?**:
- ì„œë¡œ ë‹¤ë¥¸ ì´ˆê¸° ê°€ì¤‘ì¹˜ë¡œ ì¸í•´ ëª¨ë¸ë“¤ì´ ì•½ê°„ì”© ë‹¤ë¥¸ íŒ¨í„´ì„ í•™ìŠµ
- í‰ê· ì„ ë‚´ë©´ ê°œë³„ ëª¨ë¸ì˜ ì˜¤ì°¨ê°€ ìƒì‡„ë˜ì–´ ë” ì •í™•í•œ ì˜ˆì¸¡ ê°€ëŠ¥

---

## ì˜ˆì¸¡ ë° í›„ì²˜ë¦¬

### 7.1 ìœ ì—°í•œ ì˜ˆì¸¡ í•¨ìˆ˜ (`flexible_forecast_raw`)

```python
def flexible_forecast_raw(model, df_history, df_future_meta, start_date, end_date, 
                          seq_len, feature_cols, scaler_X, scaler_y):
    model.eval()
    target_dates = pd.date_range(start=start_date, end=end_date)
    
    history = df_history.copy()
    preds = []
    
    for date in target_dates:
        # 1. ë©”íƒ€ ì •ë³´ ì¡°íšŒ
        row = df_future_meta[df_future_meta['ì˜ì—…ì¼ì'] == date].iloc[0]
        
        # 2. Lag íŠ¹ì§• ê³„ì‚° (ê³¼ê±° ë§¤ì¶œ ê¸°ë°˜)
        row['lag1'] = last_vals[-1]
        row['lag7'] = last_vals[-7] if len(last_vals) >= 7 else 0
        # ... ê¸°íƒ€ lag íŠ¹ì§•ë“¤ ...
        
        # 3. ë¡¤ë§ í†µê³„ ê³„ì‚°
        row['roll_mean7'] = pd.Series(last_vals[-7:]).mean()
        # ... ê¸°íƒ€ ë¡¤ë§ íŠ¹ì§•ë“¤ ...
        
        # 4. ë‚ ì§œ íŠ¹ì§• ì¶”ê°€
        row_df = add_date_features(pd.DataFrame([row]))
        
        # 5. ì‹œí€€ìŠ¤ ìƒì„± ë° ìŠ¤ì¼€ì¼ë§
        temp_history = pd.concat([history.tail(seq_len-1), row_df], ignore_index=True)
        seq_scaled = scaler_X.transform(temp_history[feature_cols])
        
        # 6. ì˜ˆì¸¡ ìˆ˜í–‰
        X = torch.tensor(seq_scaled, dtype=torch.float32).unsqueeze(0).to(DEVICE)
        with torch.no_grad():
            pred_scaled = model(X).item()
        
        # 7. ì—­ìŠ¤ì¼€ì¼ë§
        pred = scaler_y.inverse_transform([[pred_scaled]])[0][0]
        pred = max(pred, 0)  # ìŒìˆ˜ ë°©ì§€
        
        preds.append(pred)
        
        # 8. ì˜ˆì¸¡ê°’ì„ íˆìŠ¤í† ë¦¬ì— ì¶”ê°€ (ë‹¤ìŒ ì˜ˆì¸¡ì„ ìœ„í•´)
        row['ì¼ë§¤ì¶œ'] = pred
        history = pd.concat([history, pd.DataFrame([row])], ignore_index=True)
    
    return preds
```

**ì˜ˆì¸¡ ê³¼ì • (Auto-regressive ë°©ì‹)**:

1. **ë©”íƒ€ ì •ë³´ ì¡°íšŒ**: ì˜ˆì¸¡í•  ë‚ ì§œì˜ í•™ì‚¬ì¼ì • ì •ë³´ ê°€ì ¸ì˜¤ê¸°
2. **Lag íŠ¹ì§• ê³„ì‚°**: ê³¼ê±° ë§¤ì¶œ ë°ì´í„°ë¡œ ì§€ì—° íŠ¹ì§• ìƒì„±
3. **ë¡¤ë§ í†µê³„ ê³„ì‚°**: ìµœê·¼ Nì¼ì˜ í‰ê· /í‘œì¤€í¸ì°¨ ê³„ì‚°
4. **ë‚ ì§œ íŠ¹ì§• ì¶”ê°€**: ì›”, ì¼, ìš”ì¼ ë“± ë‚ ì§œ ê´€ë ¨ íŠ¹ì§• ì¶”ê°€
5. **ì‹œí€€ìŠ¤ ìƒì„±**: ìµœê·¼ 28ì¼ì˜ íŠ¹ì§•ì„ ì‹œí€€ìŠ¤ë¡œ êµ¬ì„±
6. **ìŠ¤ì¼€ì¼ë§**: ì •ê·œí™”ëœ ë°ì´í„°ë¡œ ë³€í™˜
7. **ëª¨ë¸ ì˜ˆì¸¡**: GRU ëª¨ë¸ë¡œ ì˜ˆì¸¡ ìˆ˜í–‰
8. **ì—­ìŠ¤ì¼€ì¼ë§**: ì›ë˜ ìŠ¤ì¼€ì¼ë¡œ ë³€í™˜
9. **íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸**: ì˜ˆì¸¡ê°’ì„ íˆìŠ¤í† ë¦¬ì— ì¶”ê°€í•˜ì—¬ ë‹¤ìŒ ì˜ˆì¸¡ì— í™œìš©

**Auto-regressiveì˜ ì˜ë¯¸**:
- ì´ì „ ì˜ˆì¸¡ê°’ì„ ë‹¤ìŒ ì˜ˆì¸¡ì˜ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš©
- ì˜ˆ: 8ì›” 10ì¼ ì˜ˆì¸¡ â†’ 8ì›” 11ì¼ ì˜ˆì¸¡ ì‹œ 8ì›” 10ì¼ ì˜ˆì¸¡ê°’ì„ lag1ë¡œ ì‚¬ìš©

---

### 7.2 ìµœì¢… í›„ì²˜ë¦¬

```python
for i, date in enumerate(target_dates):
    pred = avg_preds[i]  # ì•™ìƒë¸” í‰ê· ê°’
    
    # ë©”íƒ€ ì •ë³´ ì¡°íšŒ
    if date in test_meta['ì˜ì—…ì¼ì'].values:
        row = test_meta[test_meta['ì˜ì—…ì¼ì'] == date].iloc[0]
        
        is_sunday = (row['ì˜ì—…ì¼ì'].weekday() == 6)
        is_closed = (row.get('open_hours', 11) == 0)
        is_holiday = (row.get('acad_holiday', 0) == 1)
        
        # ğŸ”¥ íœ´ì¼ ê°•ì œ 0ì›
        if is_sunday or is_closed or is_holiday:
            pred = 0
        
    # ğŸ”¥ ë…¸ì´ì¦ˆ ì œê±°
    if pred < 10000:
        pred = 0
        
    final_preds.append(pred)
```

**í›„ì²˜ë¦¬ ê·œì¹™**:

1. **íœ´ì¼ ê°•ì œ 0ì› ì²˜ë¦¬**:
   - ì¼ìš”ì¼ (`weekday == 6`)
   - ì˜ì—… ì‹œê°„ì´ 0ì¸ ê²½ìš° (`open_hours == 0`)
   - í•™ì‚¬ íœ´ì¼ (`acad_holiday == 1`)
   - â†’ ì´ ê²½ìš° ì˜ˆì¸¡ê°’ì„ ë¬´ì¡°ê±´ 0ìœ¼ë¡œ ì„¤ì •

2. **ë…¸ì´ì¦ˆ ì œê±°**:
   - ì˜ˆì¸¡ê°’ì´ 10,000ì› ë¯¸ë§Œì¸ ê²½ìš° â†’ 0ìœ¼ë¡œ ì„¤ì •
   - ì´ìœ : ì‹¤ì œ ë§¤ì¶œì´ ë§¤ìš° ë‚®ì€ ê²½ìš°ëŠ” ê±°ì˜ ì—†ìœ¼ë©°, ëª¨ë¸ì˜ ë…¸ì´ì¦ˆì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŒ

**í›„ì²˜ë¦¬ì˜ ì¤‘ìš”ì„±**:
- ë„ë©”ì¸ ì§€ì‹ì„ í™œìš©í•œ ê·œì¹™ ê¸°ë°˜ ë³´ì •
- ëª¨ë¸ì´ í•™ìŠµí•˜ì§€ ëª»í•œ íŠ¹ìˆ˜ ìƒí™©(íœ´ì¼ ë“±) ì²˜ë¦¬
- ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë°˜ì˜

---

## ì„±ëŠ¥ í‰ê°€

### 8.1 í‰ê°€ ì§€í‘œ ê³„ì‚°

```python
comparison_df = pd.merge(actual_df, pred_df, on='ì˜ì—…ì¼ì', how='inner')
mae, rmse, smape_val = calculate_metrics(
    comparison_df['ì¼ë§¤ì¶œ_ì‹¤ì œ'], 
    comparison_df['ì˜ˆì¸¡ë§¤ì¶œ']
)
```

**í‰ê°€ ê³¼ì •**:
1. ì‹¤ì œ ë§¤ì¶œ ë°ì´í„°ì™€ ì˜ˆì¸¡ ë§¤ì¶œ ë°ì´í„°ë¥¼ ë‚ ì§œ ê¸°ì¤€ìœ¼ë¡œ ë³‘í•©
2. MAE, RMSE, SMAPE ì§€í‘œ ê³„ì‚°
3. ê²°ê³¼ë¥¼ CSV íŒŒì¼ë¡œ ì €ì¥

**ì¶œë ¥ ì˜ˆì‹œ**:
```
========================================
ğŸ“Š ì„±ëŠ¥ í‰ê°€ ê²°ê³¼ (ë¹„êµ ë°ì´í„°: 83ê°œ)
========================================
1. MAE   : 123,456.78
2. RMSE  : 234,567.89
3. SMAPE : 12.34 %
========================================
```

---

## ì „ì²´ ì‹¤í–‰ íë¦„ ìš”ì•½

```
1. ë°ì´í„° ë¡œë“œ
   â”œâ”€ í•™ìŠµ ë°ì´í„° (POS_train_val.csv)
   â”œâ”€ í…ŒìŠ¤íŠ¸ ë°ì´í„° (POS_test.csv)
   â””â”€ í•™ì‚¬ì¼ì • ë°ì´í„° (í•™ì‚¬ì¼ì •_ì •ë¦¬(2325).csv)

2. ë°ì´í„° ì „ì²˜ë¦¬
   â”œâ”€ ë§¤ì¶œ ë°ì´í„° ì •ì œ
   â”œâ”€ í•™ì‚¬ì¼ì • ë°ì´í„° ë³‘í•©
   â”œâ”€ ë‚ ì§œ íŠ¹ì§• ì¶”ê°€
   â””â”€ Lag ë° ë¡¤ë§ íŠ¹ì§• ì¶”ê°€

3. ë°ì´í„° ìŠ¤ì¼€ì¼ë§
   â”œâ”€ íŠ¹ì§• ìŠ¤ì¼€ì¼ë§ (MinMaxScaler)
   â””â”€ íƒ€ê²Ÿ ìŠ¤ì¼€ì¼ë§ (MinMaxScaler)

4. ì‹œí€€ìŠ¤ ìƒì„±
   â””â”€ Sliding Windowë¡œ í•™ìŠµ ë°ì´í„° ë³€í™˜

5. ì•™ìƒë¸” í•™ìŠµ (5ê°œ ëª¨ë¸)
   â”œâ”€ Seed 42 ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡
   â”œâ”€ Seed 100 ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡
   â”œâ”€ Seed 2024 ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡
   â”œâ”€ Seed 777 ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡
   â””â”€ Seed 999 ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡

6. ì•™ìƒë¸” í‰ê·  ê³„ì‚°
   â””â”€ 5ê°œ ëª¨ë¸ ì˜ˆì¸¡ê°’ì˜ í‰ê· 

7. í›„ì²˜ë¦¬
   â”œâ”€ íœ´ì¼ ê°•ì œ 0ì› ì²˜ë¦¬
   â””â”€ ë…¸ì´ì¦ˆ ì œê±°

8. ì„±ëŠ¥ í‰ê°€
   â””â”€ MAE, RMSE, SMAPE ê³„ì‚° ë° ì €ì¥
```

---

## ì£¼ìš” íŠ¹ì§• ìš”ì•½

### ì‚¬ìš©ëœ íŠ¹ì§• (ì´ 19ê°œ)

1. **í•™ì‚¬ì¼ì • íŠ¹ì§•** (3ê°œ):
   - `acad_weekend`, `acad_semester`, `acad_weekday`

2. **ì˜ì—… ì •ë³´** (2ê°œ):
   - `open_hours`, `acad_ceremony`, `acad_exam`

3. **ë‚ ì§œ ì£¼ê¸° íŠ¹ì§•** (4ê°œ):
   - `month_sin`, `month_cos`, `day_sin`, `day_cos`

4. **Lag íŠ¹ì§•** (4ê°œ):
   - `lag1`, `lag7`, `lag14`, `lag28`

5. **ë¡¤ë§ í†µê³„** (5ê°œ):
   - `roll_mean7`, `roll_mean14`, `roll_mean28`
   - `roll_std7`, `roll_std28`

### ëª¨ë¸ í•˜ì´í¼íŒŒë¼ë¯¸í„°

- **ëª¨ë¸**: GRU (2ì¸µ)
- **ì€ë‹‰ ì°¨ì›**: 128
- **ì‹œí€€ìŠ¤ ê¸¸ì´**: 28ì¼
- **ë°°ì¹˜ í¬ê¸°**: 32
- **í•™ìŠµë¥ **: 0.001
- **ì—í­**: 100
- **ì†ì‹¤ í•¨ìˆ˜**: MSE (Mean Squared Error)
- **ì˜µí‹°ë§ˆì´ì €**: Adam
- **ë“œë¡­ì•„ì›ƒ**: 0.3

### ì•™ìƒë¸” ì„¤ì •

- **ì•™ìƒë¸” ëª¨ë¸ ìˆ˜**: 5ê°œ
- **ì‹œë“œ**: [42, 100, 2024, 777, 999]
- **ì•™ìƒë¸” ë°©ë²•**: í‰ê·  (Mean)

---

## ê°œì„  ê°€ëŠ¥í•œ ë¶€ë¶„

1. **í•˜ì´í¼íŒŒë¼ë¯¸í„° íŠœë‹**:
   - Grid Search ë˜ëŠ” Bayesian Optimizationìœ¼ë¡œ ìµœì  í•˜ì´í¼íŒŒë¼ë¯¸í„° íƒìƒ‰

2. **ëª¨ë¸ ë‹¤ì–‘ì„± í™•ë³´**:
   - LSTM, Transformer ë“± ë‹¤ë¥¸ ì•„í‚¤í…ì²˜ ì¶”ê°€
   - ë‹¤ì–‘í•œ ì‹œí€€ìŠ¤ ê¸¸ì´ ì‹¤í—˜

3. **íŠ¹ì§• ê³µí•™**:
   - ì™¸ë¶€ ë°ì´í„° ì¶”ê°€ (ë‚ ì”¨, ì´ë²¤íŠ¸ ë“±)
   - ìƒí˜¸ì‘ìš© íŠ¹ì§• ìƒì„±

4. **ì•™ìƒë¸” ë°©ë²• ê°œì„ **:
   - ê°€ì¤‘ í‰ê·  (ì„±ëŠ¥ì´ ì¢‹ì€ ëª¨ë¸ì— ë” ë†’ì€ ê°€ì¤‘ì¹˜)
   - Stacking ì•™ìƒë¸”

5. **êµì°¨ ê²€ì¦**:
   - Time Series Cross-Validationìœ¼ë¡œ ëª¨ë¸ ì„±ëŠ¥ ê²€ì¦

---

## ì°¸ê³ ì‚¬í•­

- ì´ ì½”ë“œëŠ” Google Colab í™˜ê²½(`/content/drive/MyDrive/...`)ì—ì„œ ì‹¤í–‰ë˜ë„ë¡ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.
- ë¡œì»¬ í™˜ê²½ì—ì„œ ì‹¤í–‰ ì‹œ íŒŒì¼ ê²½ë¡œë¥¼ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤.
- GPUê°€ ì—†ì–´ë„ CPUë¡œ ì‹¤í–‰ ê°€ëŠ¥í•˜ì§€ë§Œ í•™ìŠµ ì‹œê°„ì´ ë” ì˜¤ë˜ ê±¸ë¦½ë‹ˆë‹¤.

